"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _postcss = require("postcss");

var _utils = require("../../utils");

var ruleName = "rule-properties-order";

exports.ruleName = ruleName;
var messages = (0, _utils.ruleMessages)(ruleName, {
  expected: function expected(first, second) {
    return "Expected property \"" + first + "\" to come before property \"" + second + "\"";
  },
  expectedEmptyLineBetween: function expectedEmptyLineBetween(first, second) {
    return "Expected an empty line between property \"" + first + "\" and property \"" + second + "\"";
  }
});

exports.messages = messages;

exports["default"] = function (expectation, options) {
  return function (root, result) {
    var validOptions = (0, _utils.validateOptions)(result, ruleName, {
      actual: expectation,
      possible: ["alphabetical", _lodash2["default"].isString, function (group) {
        if (!group.properties) {
          return false;
        }
        if (group.emptyLineBefore && !_lodash2["default"].isBoolean(group.emptyLineBefore)) {
          return false;
        }
        if (group.type && !_lodash2["default"].includes(["strict", "flexible"], group.type)) {
          return false;
        }
        return true;
      }]
    }, {
      actual: options,
      possible: {
        unspecified: ["top", "bottom", "ignore"]
      },
      optional: true
    });
    if (!validOptions) {
      return;
    }

    // Shallow loop
    root.each(function (node) {
      if (node.type === "rule" || node.type === "atrule") {
        checkNode(node);
      }
    });

    function checkNode(node) {
      var allPropData = [];
      var lastKnownLineSeparatedGroup = 1;

      node.each(function (child) {
        if (child.nodes && child.nodes.length) {
          checkNode(child);
        }

        if (child.type !== "decl") {
          return;
        }

        if ((0, _utils.cssPropertyIsVariable)(child.prop)) {
          return;
        }

        var unprefixedPropName = _postcss.vendor.unprefixed(child.prop);

        // Hack to allow -moz-osx-font-smoothing to be understood
        // just like -webkit-font-smoothing
        if (unprefixedPropName.indexOf("osx-") === 0) {
          unprefixedPropName = unprefixedPropName.slice(4);
        }

        var propData = {
          name: child.prop,
          unprefixedName: unprefixedPropName,
          before: child.raw("before"),
          index: allPropData.length,
          node: child
        };

        var previousPropData = _lodash2["default"].last(allPropData);
        allPropData.push(propData);

        // Skip first decl
        if (!previousPropData) {
          return;
        }

        var isCorrectOrder = expectation === "alphabetical" ? checkAlpabeticalOrder(previousPropData, propData) : checkOrder(previousPropData, propData, lastKnownLineSeparatedGroup, child);

        if (isCorrectOrder) {
          return;
        }

        (0, _utils.report)({
          message: messages.expected(propData.name, previousPropData.name),
          node: child,
          result: result,
          ruleName: ruleName
        });
      });
    }

    function checkAlpabeticalOrder(firstPropData, secondPropData) {
      // If unprefixed prop names are the same, compare the prefixed versions
      if (firstPropData.unprefixedName === secondPropData.unprefixedName) {
        return firstPropData.name <= secondPropData.name;
      }

      return firstPropData.unprefixedName < secondPropData.unprefixedName;
    }

    function checkOrder(firstPropData, secondPropData, lastKnownLineSeparatedGroup, node) {
      var expectedOrder = createExpectedOrder(expectation);

      // If the unprefixed property names are the same, resort to alphabetical ordering
      if (firstPropData.unprefixedName === secondPropData.unprefixedName) {
        return firstPropData.name <= secondPropData.name;
      }

      // By default, ignore unspecified properties
      var unspecified = _lodash2["default"].get(options, ["unspecified"], "ignore");

      var firstPropOrderValue = getOrderValue(expectedOrder, firstPropData.unprefixedName);
      var secondPropOrderValue = getOrderValue(expectedOrder, secondPropData.unprefixedName);
      var firstPropIsUnspecified = !firstPropOrderValue;
      var secondPropIsUnspecified = !secondPropOrderValue;

      // Now check newlines between ...
      var firstPropLineSeparatedGroup = !firstPropIsUnspecified ? firstPropOrderValue.lineSeparatedGroup : lastKnownLineSeparatedGroup;
      var secondPropLineSeparatedGroup = !secondPropIsUnspecified ? secondPropOrderValue.lineSeparatedGroup : lastKnownLineSeparatedGroup;
      if (firstPropLineSeparatedGroup !== secondPropLineSeparatedGroup) {
        if (!hasEmptyLineBefore(secondPropData.node)) {
          (0, _utils.report)({
            message: messages.expectedEmptyLineBetween(secondPropData.name, firstPropData.name),
            node: node,
            result: result,
            ruleName: ruleName
          });
        }
      }
      lastKnownLineSeparatedGroup = secondPropLineSeparatedGroup;

      // Now check actual known properties ...
      if (!firstPropIsUnspecified && !secondPropIsUnspecified) {
        return firstPropOrderValue.expectedPosition <= secondPropOrderValue.expectedPosition;
      }

      // Now deal with unspecified props ...

      if (firstPropIsUnspecified && secondPropIsUnspecified) {
        return true;
      }

      if (unspecified === "ignore" && (firstPropIsUnspecified || secondPropIsUnspecified)) {
        return true;
      }

      if (unspecified === "top" && firstPropIsUnspecified) {
        return true;
      }
      if (unspecified === "top" && secondPropIsUnspecified) {
        return false;
      }

      if (unspecified === "bottom" && secondPropIsUnspecified) {
        return true;
      }
      if (unspecified === "bottom" && firstPropIsUnspecified) {
        return false;
      }
    }
  };
};

function createExpectedOrder(input) {
  var expectedOrder = {};

  var lineSeparatedGroup = 1;
  var expectedPosition = 0;

  appendGroup(input, 1);

  function appendGroup(items) {
    items.forEach(function (item) {
      return appendItem(item, false);
    });
  }

  function appendItem(item, inFlexibleGroup) {
    if (_lodash2["default"].isString(item)) {
      // In flexible groups, the expectedPosition does not ascend
      // to make that flexibility work;
      // otherwise, it will always ascend
      if (!inFlexibleGroup) {
        expectedPosition += 1;
      }
      expectedOrder[item] = { lineSeparatedGroup: lineSeparatedGroup, expectedPosition: expectedPosition };
      return;
    }

    // If item is not a string, it's a group ...

    if (item.emptyLineBefore) {
      lineSeparatedGroup += 1;
    }

    if (!item.order || item.order === "strict") {
      appendGroup(item.properties);
      return;
    } else if (item.order === "flexible") {
      expectedPosition += 1;
      item.properties.forEach(function (property) {
        appendItem(property, true);
      });
    }
  }
  return expectedOrder;
}

function getOrderValue(expectedOrder, propName) {
  var orderValue = expectedOrder[propName];
  // If prop was not specified but has a hyphen
  // (e.g. `padding-top`), try looking for the segment preceding the hyphen
  // and use that index
  if (!orderValue && propName.lastIndexOf("-") !== -1) {
    var propNamePreHyphen = propName.slice(0, propName.lastIndexOf("-"));
    orderValue = getOrderValue(expectedOrder, propNamePreHyphen);
  }
  return orderValue;
}

function hasEmptyLineBefore(decl) {
  if (/\r?\n\r?\n/.test(decl.raw("before"))) {
    return true;
  }
  var prevNode = decl.prev();
  if (!prevNode) {
    return false;
  }
  if (prevNode.type !== "comment") {
    return false;
  }
  if (/\r?\n\r?\n/.test(prevNode.raw("before"))) {
    return true;
  }
  return false;
}
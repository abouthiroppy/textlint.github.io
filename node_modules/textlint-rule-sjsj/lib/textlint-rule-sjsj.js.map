{"version":3,"sources":["../src/textlint-rule-sjsj.js"],"names":[],"mappings":"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","file":"textlint-rule-sjsj.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst distanceWords = function (a, b) {\n    var matrix = new Array(a.length + 1);\n    for (let i = 0; i < a.length + 1; i++) {\n        matrix[i] = new Array(b.length + 1);\n    }\n\n    for (let i = 0; i < a.length + 1; i++) {\n        matrix[i][0] = i;\n    }\n\n    for (let j = 0; j < b.length + 1; j++) {\n        matrix[0][j] = j;\n    }\n\n    for (let i = 1; i < a.length + 1; i++) {\n        for (let j = 1; j < b.length + 1; j++) {\n            var x = a[i - 1] == b[j - 1] ? 0 : 1;\n            matrix[i][j] = Math.min(\n                matrix[i - 1][j] + 1,\n                matrix[i][j - 1] + 1,\n                matrix[i - 1][j - 1] + x\n            );\n        }\n    }\n    return matrix[a.length][b.length];\n};\nconst JARGONS = require(\"../dict/jargons.json\");\nconst defaultOptions = {\n    distance: 1\n};\nexport default function (context, options = {}) {\n    const distance = options.distance || defaultOptions.distance;\n    let {Syntax, RuleError, report, getSource} = context;\n    return {\n        [Syntax.Str](node){\n            const text = getSource(node);\n            const words = text.split(\" \").map(word => {\n                var match = word.match(/(\\w+)/);\n                return match && match[1];\n            }).filter(word => word && word.length > 0);\n            words.forEach(word => {\n                const foundMatchWord = JARGONS.some(jargon => {\n                    const jargonWord = jargon.word;\n                    // non-case sensitive\n                    // if match word then skip checking with other jargon\n                    return word.toLowerCase() === jargonWord.toLowerCase();\n                });\n                if (foundMatchWord) {\n                    return;\n                }\n                JARGONS.forEach(jargon => {\n                    const jargonWord = jargon.word;\n                    const len = distanceWords(word, jargonWord);\n                    if (len !== 0 && len <= distance) {\n                        report(node, new RuleError(`${word} => ${jargonWord}\nSee ${jargon.url} for details on.`));\n                        return true;\n                    }\n                })\n            });\n        }\n    }\n}"]}
// LICENSE : MIT
'use strict';
var Promise = require("bluebird");
var fs = require('fs');
var path = require('path');
var debug = require('debug')('textlint:cli');
var mkdirp = require('mkdirp');
var options = require('./options');
var TextLintEngine = require('./textlint-engine');
var Config = require('./config/config');
/*
 cli.js is command line **interface**

 processing role is cli-engine.js.
 @see cli-engine.js
 */
/**
 * Print results of lining text.
 * @param {string} output the output text which is formatted by {@link TextLintEngine.formatResults}
 * @param {object} options cli option object {@lint ./options.js}
 * @returns {boolean} does print result success?
 */
function printResults(output, options) {
    if (!output) {
        return true;
    }
    var outputFile = options.outputFile;
    if (outputFile) {
        var filePath = path.resolve(process.cwd(), outputFile);
        if (fs.existsSync(filePath) && fs.statSync(filePath).isDirectory()) {
            console.error('Cannot write to output file path, it is a directory: %s', outputFile);
            return false;
        }
        try {
            mkdirp.sync(path.dirname(filePath));
            fs.writeFileSync(filePath, output);
        } catch (ex) {
            console.error('There was a problem writing the output file:\n%s', ex);
            return false;
        }
    } else {
        console.log(output);
    }
    return true;
}

/**
 * Encapsulates all CLI behavior for eslint. Makes it easier to test as well as
 * for other Node.js programs to effectively run the CLI.
 */
var cli = {
    /**
     * Executes the CLI based on an array of arguments that is passed in.
     * @param {string|Array|Object} args The arguments to process.
     * @param {string} [text] The text to lint (used for TTY).
     * @returns {Promise<number>} The exit code for the operation.
     */
    execute: function execute(args, text) {
        var currentOptions;
        try {
            currentOptions = options.parse(args);
        } catch (error) {
            console.error(error.message);
            return Promise.resolve(1);
        }
        var files = currentOptions._;
        if (currentOptions.version) {
            // version from package.json
            console.log('v' + require('../package.json').version);
        } else if (currentOptions.help || !files.length && !text) {
            console.log(options.generateHelp());
        } else {
            // specify file name of stdin content
            var stdinFilename = currentOptions.stdinFilename;
            debug('Running on ' + (text ? 'text' : 'files') + ', stdin-filename: ' + stdinFilename);
            return this.executeWithOptions(currentOptions, files, text, stdinFilename);
        }
        return Promise.resolve(0);
    },
    /**
     * execute with cli options
     * @param {object} cliOptions
     * @param {string[]} files files are file path list
     * @param {string} text?
     * @param {string} stdinFilename?
     * @returns {Promise<number>} exit status
     */
    executeWithOptions: function executeWithOptions(cliOptions, files, text, stdinFilename) {
        var config = Config.initWithCLIOptions(cliOptions);
        var engine = new TextLintEngine(config);
        // TODO: should indirect access ruleManager
        if (!engine.ruleManager.hasRuleAtLeastOne()) {
            console.log('\n== Not have rules, textlint do not anything ==\n=> How to set rule?\nSee https://github.com/textlint/textlint/blob/master/docs/configuring.md\n');

            return Promise.resolve(0);
        }
        var resultsPromise = text ? engine.executeOnText(text, stdinFilename) : engine.executeOnFiles(files);
        return resultsPromise.then(function (results) {
            var output = engine.formatResults(results);
            if (printResults(output, cliOptions)) {
                return engine.isErrorResults(results) ? 1 : 0;
            } else {
                return 1;
            }
        });
    }
};
module.exports = cli;
//# sourceMappingURL=cli.js.map
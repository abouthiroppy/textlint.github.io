{"version":3,"sources":["../../src/rule/rule-context-agent.js"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,IAAM,YAAY,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC;AACxC,IAAM,WAAW,GAAG,OAAO,CAAC,wBAAwB,CAAC,CAAC;AACtD,IAAM,KAAK,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,6BAA6B,CAAC,CAAC;AAC9D,IAAM,SAAS,GAAG,OAAO,CAAC,cAAc,CAAC,CAAC;AAC1C,IAAM,eAAe,GAAG,OAAO,CAAC,oBAAoB,CAAC,CAAC;;;;;IAIjC,gBAAgB;cAAhB,gBAAgB;;AAEtB,aAFM,gBAAgB,CAErB,IAAI,EAAO,QAAQ,EAAE;YAArB,IAAI,gBAAJ,IAAI,GAAG,EAAE;;8BAFJ,gBAAgB;;AAG7B,mCAHa,gBAAgB,6CAGrB;;AAER,YAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;AACxB,YAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;AACnB,YAAI,CAAC,WAAW,GAAG,IAAI,CAAC;AACxB,YAAI,CAAC,eAAe,GAAG,QAAQ,CAAC;KACnC;;;;;;;;;;iBATgB,gBAAgB;;eAkBvB,oBAAC,IAA+B,EAAE;gBAAhC,MAAM,GAAP,IAA+B,CAA9B,MAAM;gBAAE,IAAI,GAAb,IAA+B,CAAtB,IAAI;gBAAE,QAAQ,GAAvB,IAA+B,CAAhB,QAAQ;gBAAE,KAAK,GAA9B,IAA+B,CAAN,KAAK;;AACrC,iBAAK,CAAC,eAAe,EAAE,KAAK,CAAC,CAAC;;mCACV,eAAe,CAAC,IAAI,EAAE,KAAK,CAAC;;gBAA3C,IAAI,oBAAJ,IAAI;gBAAC,MAAM,oBAAN,MAAM;;;AAEhB,gBAAI,OAAO,GAAG;AACV,sBAAM,EAAE,MAAM;AACd,uBAAO,EAAE,KAAK,CAAC,OAAO;;AAEtB,oBAAI,EAAE,IAAI;AACV,sBAAM,EAAE,MAAM,GAAG,CAAC;AAClB,wBAAQ,EAAE,QAAQ;aACrB,CAAC;AACF,gBAAI,EAAE,KAAK,YAAY,SAAS,CAAA,AAAC,EAAE;;AAE/B,oBAAI,IAAI,GAAG,KAAK,CAAC;AACjB,uBAAO,CAAC,IAAI,GAAG,IAAI,CAAC;aACvB;AACD,gBAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;SAC/B;;;;;eAGQ,qBAAG;AACR,mBAAO,WAAW,CAAC;SACtB;;;eAEU,uBAAG;AACV,mBAAO,IAAI,CAAC,eAAe,CAAC;SAC/B;;;;;;;;;;;eASQ,mBAAC,IAAI,EAAE,WAAW,EAAE,UAAU,EAAE;AACrC,gBAAI,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;AACnC,gBAAI,WAAW,IAAI,IAAI,EAAE;AACrB,uBAAO,IAAI,CAAC;aACf;AACD,gBAAI,IAAI,EAAE;AACN,oBAAI,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,WAAW,IAAI,CAAC,CAAA,AAAC,EAAE,CAAC,CAAC,CAAC;AAC5D,oBAAI,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,UAAU,IAAI,CAAC,CAAA,AAAC,CAAC;AAC5C,uBAAO,WAAW,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;aACxC,MAAM;AACH,uBAAO,WAAW,CAAC;aACtB;SACJ;;;WAlEgB,gBAAgB;GAAS,YAAY;;qBAArC,gBAAgB","file":"rule-context-agent.js","sourcesContent":["const EventEmitter = require(\"carrack\");\nconst UnionSyntax = require(\"../parser/union-syntax\");\nconst debug = require('debug')('textlint:rule-context-agent');\nconst RuleError = require(\"./rule-error\");\nconst computeLocation = require(\"./compute-location\");\n/**\n * The Agent communicate between RuleContext and Rules.\n */\nexport default class RuleContextAgent extends EventEmitter {\n\n    constructor(text = \"\", filePath) {\n        super();\n        // set unlimited listeners (see https://github.com/textlint/textlint/issues/33)\n        this.setMaxListeners(0);\n        this.messages = [];\n        this.currentText = text;\n        this.currentFilePath = filePath;\n    }\n\n    /**\n     * push new RuleError to results\n     * @param {string} ruleId\n     * @param {TxtNode} node\n     * @param {number} severity\n     * @param {RuleError|any} error error is a RuleError instance or any data\n     */\n    pushReport({ruleId, node, severity, error}) {\n        debug('pushReport %s', error);\n        let {line,column} = computeLocation(node, error);\n        // add TextLintMessage\n        let message = {\n            ruleId: ruleId,\n            message: error.message,\n            // See https://github.com/textlint/textlint/blob/master/typing/textlint.d.ts\n            line: line,        // start with 1(1-based line number)\n            column: column + 1,// start with 1(1-based column number)\n            severity: severity // it's for compatible ESLint formatter\n        };\n        if (!(error instanceof RuleError)) {\n            // `error` is a any data.\n            let data = error;\n            message.data = data;\n        }\n        this.messages.push(message);\n    }\n\n    // TODO: allow to use Syntax which is defined by Plugin Processor.\n    getSyntax() {\n        return UnionSyntax;\n    }\n\n    getFilePath() {\n        return this.currentFilePath;\n    }\n\n    /**\n     * Gets the source code for the given node.\n     * @param {TxtNode=} node The AST node to get the text for.\n     * @param {int=} beforeCount The number of characters before the node to retrieve.\n     * @param {int=} afterCount The number of characters after the node to retrieve.\n     * @returns {string|null} The text representing the AST node.\n     */\n    getSource(node, beforeCount, afterCount) {\n        let currentText = this.currentText;\n        if (currentText == null) {\n            return null;\n        }\n        if (node) {\n            let start = Math.max(node.range[0] - (beforeCount || 0), 0);\n            let end = node.range[1] + (afterCount || 0);\n            return currentText.slice(start, end);\n        } else {\n            return currentText;\n        }\n    }\n}\n"]}
{"version":3,"sources":["../../src/rule/source-code.js"],"names":[],"mappings":";;;;;;;;;;AAAA,IAAM,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC;AAC7B,IAAM,WAAW,GAAG,OAAO,CAAC,wBAAwB,CAAC,CAAC;AACtD,IAAM,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;;;;;;;;AAQjC,SAAS,QAAQ,CAAC,GAAG,EAAE;AACnB,QAAI,CAAC,GAAG,CAAC,GAAG,EAAE;AACV,cAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;KAC3D;;AAED,QAAI,CAAC,GAAG,CAAC,KAAK,EAAE;AACZ,cAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;KACvD;CACJ;;;;;;IAKoB,UAAU;AAChB,aADM,UAAU,CACf,IAA+B,EAAE;wBAAjC,IAA+B,CAA9B,IAAI;YAAJ,IAAI,6BAAG,EAAE;YAAE,GAAG,GAAf,IAA+B,CAAnB,GAAG;YAAE,GAAG,GAApB,IAA+B,CAAd,GAAG;YAAE,QAAQ,GAA9B,IAA+B,CAAT,QAAQ;;8BADzB,UAAU;;AAEvB,gBAAQ,CAAC,GAAG,CAAC,CAAC;AACd,cAAM,CAAC,GAAG,IAAI,QAAQ,EAAE,8CAA8C,CAAC,CAAC;AACxE,YAAI,CAAC,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC;AAC5C,YAAI,CAAC,IAAI,GAAI,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,AAAC,CAAC;AACjD,YAAI,CAAC,GAAG,GAAG,GAAG,CAAC;AACf,YAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;;AAEzB,YAAI,CAAC,GAAG,GAAG,GAAG,CAAC;KAClB;;iBAVgB,UAAU;;eAYlB,qBAAG;AACR,mBAAO,WAAW,CAAC;SACtB;;;eAEU,uBAAG;AACV,mBAAO,IAAI,CAAC,QAAQ,CAAC;SACxB;;;;;;;;;;;eASQ,mBAAC,IAAI,EAAE,WAAW,EAAE,UAAU,EAAE;AACrC,gBAAI,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC;AAC5B,gBAAI,WAAW,IAAI,IAAI,EAAE;AACrB,uBAAO,IAAI,CAAC;aACf;AACD,gBAAI,IAAI,EAAE;AACN,oBAAI,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,WAAW,IAAI,CAAC,CAAA,AAAC,EAAE,CAAC,CAAC,CAAC;AAC5D,oBAAI,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,UAAU,IAAI,CAAC,CAAA,AAAC,CAAC;AAC5C,uBAAO,WAAW,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;aACxC,MAAM;AACH,uBAAO,WAAW,CAAC;aACtB;SACJ;;;WAvCgB,UAAU;;;qBAAV,UAAU","file":"source-code.js","sourcesContent":["const path = require(\"path\");\nconst UnionSyntax = require(\"../parser/union-syntax\");\nconst assert = require(\"assert\");\n/**\n * Validates that the given AST has the required information.\n * @param {TxtSyntax.TxtNode} ast The Program node of the AST to check.\n * @throws {Error} If the AST doesn't contain the correct information.\n * @returns {void}\n * @private\n */\nfunction validate(ast) {\n    if (!ast.loc) {\n        throw new Error(\"AST is missing location information.\");\n    }\n\n    if (!ast.range) {\n        throw new Error(\"AST is missing range information\");\n    }\n}\n\n/**\n * This class represent of source code.\n */\nexport default class SourceCode {\n    constructor({text = \"\", ast, ext, filePath}) {\n        validate(ast);\n        assert(ext || filePath, \"should be set either of fileExt or filePath.\");\n        this.hasBOM = text.charCodeAt(0) === 0xFEFF;\n        this.text = (this.hasBOM ? text.slice(1) : text);\n        this.ast = ast;\n        this.filePath = filePath;\n        // fileType .md .txt ...\n        this.ext = ext;\n    }\n\n    getSyntax() {\n        return UnionSyntax;\n    }\n\n    getFilePath() {\n        return this.filePath;\n    }\n\n    /**\n     * Gets the source code for the given node.\n     * @param {TxtNode=} node The AST node to get the text for.\n     * @param {int=} beforeCount The number of characters before the node to retrieve.\n     * @param {int=} afterCount The number of characters after the node to retrieve.\n     * @returns {string|null} The text representing the AST node.\n     */\n    getSource(node, beforeCount, afterCount) {\n        let currentText = this.text;\n        if (currentText == null) {\n            return null;\n        }\n        if (node) {\n            let start = Math.max(node.range[0] - (beforeCount || 0), 0);\n            let end = node.range[1] + (afterCount || 0);\n            return currentText.slice(start, end);\n        } else {\n            return currentText;\n        }\n    }\n}\n"]}
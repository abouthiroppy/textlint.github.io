// LICENSE : MIT
'use strict';
/*
    textlint-core.js is a class
    textlint.js is a singleton object that is instance of textlint-core.js.
 */
Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _utilProccesorHelper = require("./util/proccesor-helper");

var _textlintPluginMarkdown = require("textlint-plugin-markdown");

var _textlintPluginText = require("textlint-plugin-text");

// add all the node types as listeners
var Promise = require("bluebird");
var EventEmitter = require("events").EventEmitter;
var TraverseController = require('txt-ast-traverse').Controller;
var traverseController = new TraverseController();
var path = require('path');
var fs = require('fs');
var assert = require('assert');
var RuleContext = require('./rule/rule-context');
var RuleContextAgent = require("./rule/rule-context-agent");
var debug = require('debug')('textlint:core');
var timing = require("./util/timing");
function addListenRule(key, rule, target) {
    Object.keys(rule).forEach(function (nodeType) {
        target.on(nodeType, timing.enabled ? timing.time(key, rule[nodeType]) : rule[nodeType]);
    });
}

var TextlintCore = (function () {
    function TextlintCore() {
        var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        _classCallCheck(this, TextlintCore);

        // this.config often is undefined.
        this.config = config;
        this.rules = {};
        this.rulesConfig = {};
        // FIXME: in the future, this.processors is empty by default.
        // Markdown and Text are for backward compatibility.
        this.processors = [new _textlintPluginMarkdown.Processor(config), new _textlintPluginText.Processor(config)];
    }

    // unstable API

    _createClass(TextlintCore, [{
        key: "addProcessor",
        value: function addProcessor(Processtor) {
            // add first
            this.processors.unshift(new Processtor(this.config));
        }

        /**
         * Register rules to EventEmitter.
         * if want to release rules, please call {@link this.resetRules}.
         * @param {object} rules rule objects array
         * @param {object} [rulesConfig] ruleConfig is object
         */
    }, {
        key: "setupRules",
        value: function setupRules() {
            var rules = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
            var rulesConfig = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            var ignoreDisableRules = function ignoreDisableRules(rules) {
                var resultRules = Object.create(null);
                Object.keys(rules).forEach(function (key) {
                    var ruleCreator = rules[key];
                    if (typeof ruleCreator !== 'function') {
                        throw new Error("Definition of rule '" + key + "' was not found.");
                    }
                    // "rule-name" : false => disable
                    var ruleConfig = rulesConfig && rulesConfig[key];
                    if (ruleConfig !== false) {
                        debug('use "%s" rule', key);
                        resultRules[key] = rules[key];
                    }
                });
                return resultRules;
            };
            this.rules = ignoreDisableRules(rules);
            this.rulesConfig = rulesConfig;
        }
    }, {
        key: "_createRuleContextAgent",
        value: function _createRuleContextAgent(text, filePath) {
            var _this = this;

            var rules = this.rules;
            var ruleContextAgent = new RuleContextAgent(text, filePath);
            Object.keys(rules).forEach(function (key) {
                var ruleCreator = rules[key];
                var ruleConfig = _this.rulesConfig[key];
                try {
                    var ruleContext = new RuleContext(key, ruleContextAgent, _this.config, ruleConfig);
                    var rule = ruleCreator(ruleContext, ruleConfig);
                    addListenRule(key, rule, ruleContextAgent);
                } catch (ex) {
                    ex.message = "Error while loading rule '" + key + "': " + ex.message;
                    throw ex;
                }
            });
            return ruleContextAgent;
        }

        /**
         * Remove all registered rule and clear messages.
         */
    }, {
        key: "resetRules",
        value: function resetRules() {
            // noop
        }
    }, {
        key: "_lintByProcessor",
        value: function _lintByProcessor(processor, text, ext, filePath) {
            assert(processor, "processor is not found for " + ext);

            var _processor$processor = processor.processor(ext);

            var preProcess = _processor$processor.preProcess;
            var postProcess = _processor$processor.postProcess;

            assert(typeof preProcess === "function" && typeof postProcess === "function", "processor should implement {preProcess, postProcess}");
            var ast = preProcess(text, filePath);
            var promiseQueue = [];
            var ruleContextAgent = this._createRuleContextAgent(text, filePath);
            var listenerCount = typeof ruleContextAgent.listenerCount !== 'undefined' ? ruleContextAgent.listenerCount.bind(ruleContextAgent) // Node 4.x >=
            : EventEmitter.listenerCount.bind(EventEmitter, ruleContextAgent); // Node 0.12
            traverseController.traverse(ast, {
                enter: function enter(node, parent) {
                    var type = node.type;
                    Object.defineProperty(node, 'parent', { value: parent });
                    if (listenerCount(type) > 0) {
                        var promise = ruleContextAgent.emit(type, node);
                        promiseQueue.push(promise);
                    }
                },
                leave: function leave(node) {
                    var type = node.type + ":exit";
                    if (listenerCount(type) > 0) {
                        var promise = ruleContextAgent.emit(type, node);
                        promiseQueue.push(promise);
                    }
                }
            });
            return Promise.all(promiseQueue).then(function () {
                var messages = ruleContextAgent.messages;
                var result = postProcess(messages, filePath);
                if (result.filePath == null) {
                    result.filePath = "<Unkown" + ext + ">";
                }
                assert(result.filePath && result.messages.length >= 0, "postProcess should return { messages, filePath } ");
                return result;
            });
        }

        /**
         * lint text by registered rules.
         * The result contains target filePath and error messages.
         * @param {string} text
         * @param {string} ext ext is extension. default: .txt
         * @returns {TextLintResult}
         */
    }, {
        key: "lintText",
        value: function lintText(text) {
            var ext = arguments.length <= 1 || arguments[1] === undefined ? ".txt" : arguments[1];

            var processor = (0, _utilProccesorHelper.getProcessorMatchExtension)(this.processors, ext);
            return this._lintByProcessor(processor, text, ext);
        }

        /**
         * lint markdown text by registered rules.
         * The result contains target filePath and error messages.
         * @param {string} text markdown format text
         * @returns {TextLintResult}
         */
    }, {
        key: "lintMarkdown",
        value: function lintMarkdown(text) {
            var ext = ".md";
            var processor = (0, _utilProccesorHelper.getProcessorMatchExtension)(this.processors, ext);
            return this._lintByProcessor(processor, text, ext);
        }

        /**
         * lint file and return result object
         * @param {string} filePath
         * @returns {TextLintResult} result
         */
    }, {
        key: "lintFile",
        value: function lintFile(filePath) {
            var absoluteFilePath = path.resolve(process.cwd(), filePath);
            var ext = path.extname(absoluteFilePath);
            var text = fs.readFileSync(absoluteFilePath, 'utf-8');
            var processor = (0, _utilProccesorHelper.getProcessorMatchExtension)(this.processors, ext);
            return this._lintByProcessor(processor, text, ext, absoluteFilePath);
        }
    }]);

    return TextlintCore;
})();

exports["default"] = TextlintCore;
module.exports = exports["default"];
//# sourceMappingURL=textlint-core.js.map